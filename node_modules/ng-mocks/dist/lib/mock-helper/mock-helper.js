"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ngMocks = exports.MockHelper = void 0;
const testing_1 = require("@angular/core/testing");
const platform_browser_1 = require("@angular/platform-browser");
const common_1 = require("../common");
const reflect_1 = require("../common/reflect");
const mock_service_1 = require("../mock-service");
function nestedCheck(result, node, callback) {
    const element = callback(node);
    if (element) {
        result.push(element);
    }
    const childNodes = node.childNodes ? node.childNodes : [];
    childNodes.forEach(childNode => {
        nestedCheck(result, childNode, callback);
    });
}
exports.MockHelper = {
    getInput: (debugNode, input) => exports.ngMocks.input(debugNode, input, undefined),
    getInputOrFail: (debugNode, input) => exports.ngMocks.input(debugNode, input),
    getOutput: (debugNode, output) => exports.ngMocks.output(debugNode, output, undefined),
    getOutputOrFail: (debugNode, output) => exports.ngMocks.output(debugNode, output),
    getDirectiveOrFail: (debugNode, directive) => exports.ngMocks.get(debugNode, directive),
    getDirective: (debugNode, directive) => exports.ngMocks.get(debugNode, directive, undefined),
    findDirectiveOrFail: (debugNode, directive) => exports.ngMocks.findInstance(debugNode, directive),
    findDirective: (debugNode, directive) => exports.ngMocks.findInstance(debugNode, directive, undefined),
    findDirectives: (debugNode, directive) => exports.ngMocks.findInstances(debugNode, directive),
    findOrFail: (el, sel) => exports.ngMocks.find(el, sel),
    find: (el, sel) => exports.ngMocks.find(el, sel, null),
    findAll: (el, sel) => exports.ngMocks.findAll(el, sel),
    mockService: (instance, override, style) => typeof override === 'object' ? exports.ngMocks.stub(instance, override) : exports.ngMocks.stub(instance, override, style),
};
const defaultNotFoundValue = {};
exports.ngMocks = {
    find: (...args) => {
        const el = args[0];
        const sel = args[1];
        const notFoundValue = args.length === 3 ? args[2] : defaultNotFoundValue;
        const term = typeof sel === 'string' ? platform_browser_1.By.css(sel) : platform_browser_1.By.directive(common_1.getSourceOfMock(sel));
        const result = el.query(term);
        if (result) {
            return result;
        }
        if (notFoundValue !== defaultNotFoundValue) {
            return notFoundValue;
        }
        if (!result) {
            throw new Error(`Cannot find an element via ngMocks.find(${typeof sel === 'string' ? sel : sel.name})`);
        }
    },
    findAll: (el, sel) => {
        const term = typeof sel === 'string' ? platform_browser_1.By.css(sel) : platform_browser_1.By.directive(common_1.getSourceOfMock(sel));
        return el.queryAll(term);
    },
    findInstance: (...args) => {
        const el = args[0];
        const sel = args[1];
        const notFoundValue = args.length === 3 ? args[2] : defaultNotFoundValue;
        const result = exports.ngMocks.findInstances(el, common_1.getSourceOfMock(sel));
        if (result.length) {
            return result[0];
        }
        if (notFoundValue !== defaultNotFoundValue) {
            return notFoundValue;
        }
        throw new Error(`Cannot find ${sel.name} directive via ngMocks.findInstance`);
    },
    findInstances: (el, sel) => {
        const result = [];
        nestedCheck(result, el, node => {
            try {
                return node.injector.get(common_1.getSourceOfMock(sel));
            }
            catch (error) {
                return undefined;
            }
        });
        return result;
    },
    get: (...args) => {
        const el = args[0];
        const sel = args[1];
        const notFoundValue = args.length === 3 ? args[2] : defaultNotFoundValue;
        let notFound = false;
        try {
            return el.injector.get(common_1.getSourceOfMock(sel));
        }
        catch (error) {
        }
        const prevNode = notFound ? undefined : el.nativeNode.previousSibling;
        if (!prevNode || prevNode.nodeName !== '#comment') {
            notFound = true;
        }
        const matches = notFound || !el || !el.parent ? [] : el.parent.queryAllNodes(node => node.nativeNode === prevNode);
        if (matches.length === 0) {
            notFound = true;
        }
        const matchedNode = matches[0];
        try {
            return matchedNode.injector.get(common_1.getSourceOfMock(sel));
        }
        catch (error) {
            notFound = true;
        }
        if (notFound && notFoundValue !== defaultNotFoundValue) {
            return notFoundValue;
        }
        throw new Error(`Cannot find ${sel.name} directive via ngMocks.get`);
    },
    input: (...args) => {
        const el = args[0];
        const sel = args[1];
        const notFoundValue = args.length === 3 ? args[2] : defaultNotFoundValue;
        for (const token of el.providerTokens) {
            if (common_1.isNgInjectionToken(token)) {
                continue;
            }
            let meta;
            if (!meta) {
                try {
                    meta = reflect_1.directiveResolver.resolve(token);
                }
                catch (e) {
                    throw new Error('ng-mocks is not in JIT mode and cannot resolve declarations');
                }
            }
            const { inputs } = meta;
            if (!inputs) {
                continue;
            }
            for (const inputDef of inputs) {
                const [prop = '', alias = ''] = inputDef.split(':', 2).map(v => v.trim());
                if (!prop) {
                    continue;
                }
                if (!alias && prop !== sel) {
                    continue;
                }
                if (alias && alias !== sel) {
                    continue;
                }
                const directive = exports.ngMocks.get(el, token, undefined);
                if (!directive) {
                    continue;
                }
                return directive[prop];
            }
        }
        if (notFoundValue !== defaultNotFoundValue) {
            return notFoundValue;
        }
        throw new Error(`Cannot find ${sel} input via ngMocks.input`);
    },
    output: (...args) => {
        const el = args[0];
        const sel = args[1];
        const notFoundValue = args.length === 3 ? args[2] : defaultNotFoundValue;
        for (const token of el.providerTokens) {
            if (common_1.isNgInjectionToken(token)) {
                continue;
            }
            let meta;
            if (!meta) {
                try {
                    meta = reflect_1.directiveResolver.resolve(token);
                }
                catch (e) {
                    throw new Error('ng-mocks is not in JIT mode and cannot resolve declarations');
                }
            }
            const { outputs } = meta;
            if (!outputs) {
                continue;
            }
            for (const outputDef of outputs) {
                const [prop = '', alias = ''] = outputDef.split(':', 2).map(v => v.trim());
                if (!prop) {
                    continue;
                }
                if (!alias && prop !== sel) {
                    continue;
                }
                if (alias && alias !== sel) {
                    continue;
                }
                const directive = exports.ngMocks.get(el, token, undefined);
                if (!directive) {
                    continue;
                }
                return directive[prop];
            }
        }
        if (notFoundValue !== defaultNotFoundValue) {
            return notFoundValue;
        }
        throw new Error(`Cannot find ${sel} input via ngMocks.output`);
    },
    stub: (instance, override, style) => {
        if (typeof override === 'string') {
            return mock_service_1.mockServiceHelper.mock(instance, override, style);
        }
        for (const key of Object.getOwnPropertyNames(override)) {
            const def = Object.getOwnPropertyDescriptor(override, key);
            if (def) {
                Object.defineProperty(instance, key, def);
            }
        }
        return instance;
    },
    flushTestBed() {
        testing_1.getTestBed()._instantiated = false;
        testing_1.getTestBed()._moduleFactory = undefined;
        testing_1.getTestBed()._testModuleRef = null;
    },
};
//# sourceMappingURL=mock-helper.js.map