"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockService = exports.mockServiceHelper = void 0;
const isFunc = (value) => {
    if (typeof value !== 'function') {
        return false;
    }
    const proto = value.toString();
    if (proto.match(/^\(/) !== null) {
        return true;
    }
    return proto.match(/^function\s*\(/) !== null;
};
const isClass = (value) => {
    if (typeof value !== 'function') {
        return false;
    }
    if (isFunc(value)) {
        return false;
    }
    const proto = value.toString();
    if (proto.match(/^class\b/) !== null) {
        return true;
    }
    return proto.match(/^function\s*\(/) === null;
};
const isInst = (value) => {
    if (value === null) {
        return false;
    }
    if (typeof value !== 'object') {
        return false;
    }
    if (value.ngMetadataName === 'InjectionToken') {
        return false;
    }
    return typeof Object.getPrototypeOf(value) === 'object';
};
let customMockFunction;
const mockServiceHelperPrototype = {
    mockFunction: (mockName, original = false) => {
        if (customMockFunction && !original) {
            return customMockFunction(mockName);
        }
        let value;
        let setValue;
        const func = (val) => {
            if (setValue) {
                setValue(val);
            }
            return value;
        };
        func.__ngMocks = true;
        func.__ngMocksSet = (newSetValue) => (setValue = newSetValue);
        func.__ngMocksGet = (newValue) => (value = newValue);
        return func;
    },
    registerMockFunction: (mockFunction) => {
        customMockFunction = mockFunction;
    },
    createMockFromPrototype: (service) => {
        const methods = mockServiceHelperPrototype.extractMethodsFromPrototype(service);
        const value = {};
        for (const method of methods) {
            if (value[method]) {
                continue;
            }
            const mockName = `${service.constructor ? service.constructor.name : 'unknown'}.${method}`;
            value[method] = mockServiceHelperPrototype.mockFunction(mockName);
        }
        if (typeof value === 'object' && typeof service === 'object') {
            Object.setPrototypeOf(value, service);
        }
        return value;
    },
    extractMethodsFromPrototype: (service) => {
        const result = [];
        let prototype = service;
        while (prototype && Object.getPrototypeOf(prototype) !== null) {
            for (const method of Object.getOwnPropertyNames(prototype)) {
                if (method === 'constructor') {
                    continue;
                }
                const descriptor = Object.getOwnPropertyDescriptor(prototype, method);
                const isGetterSetter = descriptor && (descriptor.get || descriptor.set);
                if (isGetterSetter || result.indexOf(method) !== -1) {
                    continue;
                }
                result.push(method);
            }
            prototype = Object.getPrototypeOf(prototype);
        }
        return result;
    },
    extractPropertiesFromPrototype: (service) => {
        const result = [];
        let prototype = service;
        while (prototype && Object.getPrototypeOf(prototype) !== null) {
            for (const prop of Object.getOwnPropertyNames(prototype)) {
                if (prop === 'constructor') {
                    continue;
                }
                const descriptor = Object.getOwnPropertyDescriptor(prototype, prop);
                const isGetterSetter = descriptor && (descriptor.get || descriptor.set);
                if (!isGetterSetter || result.indexOf(prop) !== -1) {
                    continue;
                }
                result.push(prop);
            }
            prototype = Object.getPrototypeOf(prototype);
        }
        return result;
    },
    extractPropertyDescriptor: (service, prop) => {
        let prototype = service;
        while (prototype && Object.getPrototypeOf(prototype) !== null) {
            const descriptor = Object.getOwnPropertyDescriptor(prototype, prop);
            if (descriptor) {
                return descriptor;
            }
            prototype = Object.getPrototypeOf(prototype);
        }
    },
    mock: (instance, name, accessType) => {
        const def = Object.getOwnPropertyDescriptor(instance, name);
        if (def && def[accessType || 'value']) {
            return def[accessType || 'value'];
        }
        const mockName = `${typeof instance.prototype === 'function'
            ? instance.prototype.name
            : typeof instance.constructor === 'function'
                ? instance.constructor.name
                : 'unknown'}.${name}${accessType ? `:${accessType}` : ''}`;
        const mock = mockServiceHelperPrototype.mockFunction(mockName, !!accessType);
        const mockDef = Object.assign(Object.assign(Object.assign(Object.assign({}, (accessType === 'get' && def && def.set
            ? {
                set: def.set,
            }
            : {})), (accessType === 'set' && def && def.get
            ? {
                get: def.get,
            }
            : {})), (accessType
            ? {}
            : {
                writable: true,
            })), { [accessType || 'value']: mock, configurable: true, enumerable: true });
        if (mockDef.get && mockDef.set && mockDef.get.__ngMocks && mockDef.set.__ngMocks) {
            mockDef.set.__ngMocksSet((val) => mockDef.get.__ngMocksGet(val));
        }
        Object.defineProperty(instance, name, mockDef);
        return mock;
    },
};
(window || global).ngMocksMockServiceHelper =
    (window || global).ngMocksMockServiceHelper || mockServiceHelperPrototype;
const localHelper = (window || global).ngMocksMockServiceHelper;
exports.mockServiceHelper = (window || global).ngMocksMockServiceHelper;
function MockService(service, mockNamePrefix) {
    let value;
    if (isClass(service)) {
        value = localHelper.createMockFromPrototype(service.prototype);
    }
    else if (isFunc(service)) {
        value = localHelper.mockFunction(`func:${mockNamePrefix ? mockNamePrefix : service.name || 'arrow-function'}`);
    }
    else if (Array.isArray(service)) {
        value = [];
    }
    else if (isInst(service)) {
        value =
            typeof service.constructor === 'function'
                ? localHelper.createMockFromPrototype(service.constructor.prototype)
                : {};
        for (const property of Object.keys(service)) {
            const mock = MockService(service[property], `${mockNamePrefix ? mockNamePrefix : 'instance'}.${property}`);
            if (mock !== undefined) {
                value[property] = mock;
            }
        }
        Object.setPrototypeOf(value, Object.getPrototypeOf(service));
    }
    return value;
}
exports.MockService = MockService;
//# sourceMappingURL=mock-service.js.map