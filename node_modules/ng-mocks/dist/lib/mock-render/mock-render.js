"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockRender = void 0;
const core_1 = require("@angular/core");
const testing_1 = require("@angular/core/testing");
const rxjs_1 = require("rxjs");
const reflect_1 = require("../common/reflect");
const mock_helper_1 = require("../mock-helper");
const mock_service_1 = require("../mock-service");
function solveOutput(output) {
    if (typeof output === 'function') {
        return '($event)';
    }
    if (output && typeof output === 'object' && output instanceof core_1.EventEmitter) {
        return '.emit($event)';
    }
    if (output && typeof output === 'object' && output instanceof rxjs_1.Subject) {
        return '.next($event)';
    }
    return '=$event';
}
function MockRender(template, params, flags = true) {
    const flagsObject = typeof flags === 'boolean' ? { detectChanges: flags } : flags;
    const isComponent = typeof template !== 'string';
    const noParams = !params;
    let inputs = [];
    let outputs = [];
    let selector = '';
    let mockedTemplate = '';
    if (typeof template === 'string') {
        mockedTemplate = template;
    }
    else {
        let meta;
        if (!meta) {
            try {
                meta = reflect_1.directiveResolver.resolve(template);
            }
            catch (e) {
                throw new Error('ng-mocks is not in JIT mode and cannot resolve declarations');
            }
        }
        inputs = meta.inputs;
        outputs = meta.outputs;
        selector = meta.selector;
        mockedTemplate += selector ? `<${selector}` : '';
        if (selector && inputs) {
            inputs.forEach((definition) => {
                const [property, alias] = definition.split(': ');
                if (alias && params && typeof params[alias]) {
                    mockedTemplate += ` [${alias}]="${alias}"`;
                }
                else if (property && params && typeof params[property]) {
                    mockedTemplate += ` [${property}]="${property}"`;
                }
                else if (alias && noParams) {
                    mockedTemplate += ` [${alias}]="${property}"`;
                }
                else if (noParams) {
                    mockedTemplate += ` [${property}]="${property}"`;
                }
            });
        }
        if (selector && outputs) {
            outputs.forEach((definition) => {
                const [property, alias] = definition.split(': ');
                if (alias && params && typeof params[alias]) {
                    mockedTemplate += ` (${alias})="${alias}${solveOutput(params[alias])}"`;
                }
                else if (property && params && typeof params[property]) {
                    mockedTemplate += ` (${property})="${property}${solveOutput(params[property])}"`;
                }
                else if (alias && noParams) {
                    mockedTemplate += ` (${alias})="${property}.emit($event)"`;
                }
                else if (noParams) {
                    mockedTemplate += ` (${property})="${property}.emit($event)"`;
                }
            });
        }
        mockedTemplate += selector ? `></${selector}>` : '';
    }
    const options = {
        providers: flagsObject.providers,
        selector: 'mock-render',
        template: mockedTemplate,
    };
    const component = core_1.Component(options)(class MockRenderComponent {
        constructor() {
            for (const key of Object.keys(params || {})) {
                this[key] = params[key];
            }
            if (noParams && isComponent && inputs) {
                for (const definition of inputs) {
                    const [property] = definition.split(': ');
                    this[property] = undefined;
                }
            }
            if (noParams && isComponent && outputs) {
                for (const definition of outputs) {
                    const [property] = definition.split(': ');
                    this[property] = new core_1.EventEmitter();
                }
            }
        }
    });
    mock_helper_1.ngMocks.flushTestBed();
    testing_1.TestBed.configureTestingModule({
        declarations: [component],
    });
    const fixture = testing_1.TestBed.createComponent(component);
    if (flagsObject.detectChanges) {
        fixture.detectChanges();
    }
    fixture.point = fixture.debugElement.children[0];
    if (noParams && typeof template === 'function') {
        const properties = mock_service_1.mockServiceHelper.extractPropertiesFromPrototype(template.prototype);
        const exists = Object.getOwnPropertyNames(fixture.componentInstance);
        for (const property of properties) {
            if (exists.indexOf(property) !== -1) {
                continue;
            }
            Object.defineProperty(fixture.componentInstance, property, {
                get: () => fixture.point.componentInstance[property],
                set: (v) => (fixture.point.componentInstance[property] = v),
                configurable: true,
                enumerable: true,
            });
        }
        const methods = mock_service_1.mockServiceHelper.extractMethodsFromPrototype(template.prototype);
        for (const method of methods) {
            if (exists.indexOf(method) !== -1) {
                continue;
            }
            Object.defineProperty(fixture.componentInstance, method, {
                value: (...args) => fixture.point.componentInstance[method](...args),
                configurable: true,
                enumerable: true,
                writable: true,
            });
        }
    }
    return fixture;
}
exports.MockRender = MockRender;
//# sourceMappingURL=mock-render.js.map