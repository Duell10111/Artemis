"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockModule = exports.MockProvider = void 0;
const common_1 = require("@angular/common");
const core_1 = require("@angular/core");
const testing_1 = require("@angular/core/testing");
const common_2 = require("../common");
const ng_mocks_universe_1 = require("../common/ng-mocks-universe");
const reflect_1 = require("../common/reflect");
const mock_component_1 = require("../mock-component");
const mock_directive_1 = require("../mock-directive");
const mock_pipe_1 = require("../mock-pipe");
const mock_service_1 = require("../mock-service");
const neverMockProvidedFunction = ['DomRendererFactory2', 'RendererFactory2'];
function MockProvider(provider) {
    const provide = typeof provider === 'object' && provider.provide ? provider.provide : provider;
    if (ng_mocks_universe_1.ngMocksUniverse.flags.has('cacheProvider') && ng_mocks_universe_1.ngMocksUniverse.cache.has(provide)) {
        return ng_mocks_universe_1.ngMocksUniverse.cache.get(provide);
    }
    if (typeof provide === 'object' && provide.ngMetadataName === 'InjectionToken') {
        return undefined;
    }
    if (typeof provide === 'function' && neverMockProvidedFunction.indexOf(provide.name) !== -1) {
        return provider;
    }
    const mockedProvider = {
        provide,
        useValue: mock_service_1.MockService(provide),
    };
    if (ng_mocks_universe_1.ngMocksUniverse.flags.has('cacheProvider')) {
        ng_mocks_universe_1.ngMocksUniverse.cache.set(provide, mockedProvider);
    }
    return mockedProvider;
}
exports.MockProvider = MockProvider;
function MockModule(module) {
    let ngModule;
    let ngModuleProviders;
    let mockModule;
    let mockModuleProviders;
    let mockModuleDef;
    let releaseSkipMockFlag = false;
    if (common_2.isNgModuleDefWithProviders(module)) {
        ngModule = module.ngModule;
        if (module.providers) {
            ngModuleProviders = module.providers;
        }
    }
    else {
        ngModule = module;
    }
    if (NEVER_MOCK.indexOf(ngModule) !== -1) {
        return module;
    }
    if (!ngModuleProviders && testing_1.getTestBed()._instantiated) {
        try {
            return common_2.getMockedNgDefOf(ngModule, 'm');
        }
        catch (error) {
        }
    }
    if (ng_mocks_universe_1.ngMocksUniverse.flags.has('cacheModule') && ng_mocks_universe_1.ngMocksUniverse.cache.has(ngModule)) {
        mockModule = ng_mocks_universe_1.ngMocksUniverse.cache.get(ngModule);
    }
    if (!mockModule && ng_mocks_universe_1.ngMocksUniverse.builder.has(ngModule)) {
        const instance = ng_mocks_universe_1.ngMocksUniverse.builder.get(ngModule);
        if (common_2.isNgDef(instance, 'm') && instance !== ngModule) {
            mockModule = instance;
        }
        if (!ng_mocks_universe_1.ngMocksUniverse.flags.has('skipMock')) {
            releaseSkipMockFlag = true;
            ng_mocks_universe_1.ngMocksUniverse.flags.add('skipMock');
        }
    }
    if (!mockModule) {
        let meta;
        if (!meta) {
            try {
                meta = reflect_1.ngModuleResolver.resolve(ngModule);
            }
            catch (e) {
                throw new Error('ng-mocks is not in JIT mode and cannot resolve declarations');
            }
        }
        const [changed, ngModuleDef] = MockNgModuleDef(meta, ngModule);
        if (changed) {
            mockModuleDef = ngModuleDef;
        }
    }
    if (mockModuleDef) {
        const parent = ng_mocks_universe_1.ngMocksUniverse.flags.has('skipMock') ? ngModule : common_2.Mock;
        let ModuleMock = class ModuleMock extends parent {
        };
        ModuleMock = __decorate([
            core_1.NgModule(mockModuleDef),
            common_2.MockOf(ngModule)
        ], ModuleMock);
        mockModule = ModuleMock;
        if (ng_mocks_universe_1.ngMocksUniverse.flags.has('cacheModule')) {
            ng_mocks_universe_1.ngMocksUniverse.cache.set(ngModule, mockModule);
        }
    }
    if (!mockModule) {
        mockModule = ngModule;
    }
    if (ngModuleProviders) {
        const [changed, ngModuleDef] = MockNgModuleDef({ providers: ngModuleProviders });
        mockModuleProviders = changed ? ngModuleDef.providers : ngModuleProviders;
    }
    if (releaseSkipMockFlag) {
        ng_mocks_universe_1.ngMocksUniverse.flags.delete('skipMock');
    }
    return mockModule === ngModule && mockModuleProviders === ngModuleProviders
        ? module
        : common_2.isNgModuleDefWithProviders(module)
            ? Object.assign({ ngModule: mockModule }, (mockModuleProviders ? { providers: mockModuleProviders } : {})) : mockModule;
}
exports.MockModule = MockModule;
const NEVER_MOCK = [common_1.CommonModule, core_1.ApplicationModule];
function MockNgModuleDef(ngModuleDef, ngModule) {
    let changed = !ng_mocks_universe_1.ngMocksUniverse.flags.has('skipMock');
    const mockedModuleDef = {};
    const { bootstrap = [], declarations = [], entryComponents = [], exports = [], imports = [], providers = [], } = ngModuleDef;
    const resolutions = new Map();
    const resolveProvider = (def) => {
        const provider = typeof def === 'object' && def.provide ? def.provide : def;
        const multi = def !== provider && !!def.multi;
        let mockedDef;
        if (resolutions.has(provider)) {
            mockedDef = resolutions.get(provider);
            return multi && typeof mockedDef === 'object' ? Object.assign(Object.assign({}, mockedDef), { multi }) : mockedDef;
        }
        ng_mocks_universe_1.ngMocksUniverse.touches.add(provider);
        if (!mockedDef && ng_mocks_universe_1.ngMocksUniverse.builder.has(provider)) {
            mockedDef = ng_mocks_universe_1.ngMocksUniverse.builder.get(provider);
            if (mockedDef === provider) {
                mockedDef = def;
            }
            else if (mockedDef === undefined) {
                mockedDef = {
                    provide: provider,
                    useValue: undefined,
                };
            }
        }
        if (!mockedDef && ng_mocks_universe_1.ngMocksUniverse.flags.has('skipMock')) {
            mockedDef = def;
        }
        if (!mockedDef) {
            mockedDef = MockProvider(def);
        }
        if (!common_2.isNgInjectionToken(provider) || def !== mockedDef) {
            resolutions.set(provider, mockedDef);
        }
        changed = changed || mockedDef !== def;
        return multi && typeof mockedDef === 'object' ? Object.assign(Object.assign({}, mockedDef), { multi }) : mockedDef;
    };
    const resolve = (def) => {
        let mockedDef;
        if (resolutions.has(def)) {
            return resolutions.get(def);
        }
        ng_mocks_universe_1.ngMocksUniverse.touches.add(common_2.isNgModuleDefWithProviders(def) ? def.ngModule : def);
        if (!mockedDef && common_2.isNgDef(def, 'm')) {
            mockedDef = MockModule(def);
        }
        if (!mockedDef && common_2.isNgModuleDefWithProviders(def)) {
            mockedDef = MockModule(def);
            resolutions.set(def.ngModule, mockedDef.ngModule);
        }
        if (!mockedDef && ng_mocks_universe_1.ngMocksUniverse.builder.has(def)) {
            mockedDef = ng_mocks_universe_1.ngMocksUniverse.builder.get(def);
        }
        if (!mockedDef && ng_mocks_universe_1.ngMocksUniverse.flags.has('skipMock')) {
            mockedDef = def;
        }
        if (!mockedDef && common_2.isNgDef(def, 'c')) {
            mockedDef = mock_component_1.MockComponent(def);
        }
        if (!mockedDef && common_2.isNgDef(def, 'd')) {
            mockedDef = mock_directive_1.MockDirective(def);
        }
        if (!mockedDef && common_2.isNgDef(def, 'p')) {
            mockedDef = mock_pipe_1.MockPipe(def);
        }
        if (!mockedDef) {
            mockedDef = resolveProvider(def);
        }
        resolutions.set(def, mockedDef);
        changed = changed || mockedDef !== def;
        return mockedDef;
    };
    if (imports && imports.length) {
        mockedModuleDef.imports = common_2.flatten(imports).map(resolve);
    }
    if (declarations && declarations.length) {
        mockedModuleDef.declarations = common_2.flatten(declarations).map(resolve);
    }
    if (entryComponents && entryComponents.length) {
        mockedModuleDef.entryComponents = common_2.flatten(entryComponents).map(resolve);
    }
    if (bootstrap && bootstrap.length) {
        mockedModuleDef.bootstrap = common_2.flatten(bootstrap).map(resolve);
    }
    if (providers && providers.length) {
        mockedModuleDef.providers = common_2.flatten(providers)
            .map(resolveProvider)
            .filter(provider => provider);
    }
    if (exports && exports.length) {
        mockedModuleDef.exports = common_2.flatten(exports).map(resolve);
    }
    const correctExports = ng_mocks_universe_1.ngMocksUniverse.flags.has('skipMock') || ng_mocks_universe_1.ngMocksUniverse.flags.has('correctModuleExports');
    for (const def of common_2.flatten([imports || [], declarations || []])) {
        const instance = common_2.isNgModuleDefWithProviders(def) ? def.ngModule : def;
        const mockedDef = resolve(instance);
        const config = ng_mocks_universe_1.ngMocksUniverse.config.get(instance) || {};
        if (config.export && ngModule) {
            const moduleConfig = ng_mocks_universe_1.ngMocksUniverse.config.get(ngModule) || {};
            if (!moduleConfig.export) {
                moduleConfig.export = true;
                ng_mocks_universe_1.ngMocksUniverse.config.set(ngModule, moduleConfig);
            }
        }
        if (correctExports && !config.export) {
            continue;
        }
        if (mockedModuleDef.exports && mockedModuleDef.exports.indexOf(mockedDef) !== -1) {
            continue;
        }
        changed = true;
        mockedModuleDef.exports = mockedModuleDef.exports || [];
        mockedModuleDef.exports.push(mockedDef);
    }
    return [changed, mockedModuleDef];
}
//# sourceMappingURL=mock-module.js.map