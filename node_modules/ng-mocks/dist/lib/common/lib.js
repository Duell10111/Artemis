"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSourceOfMock = exports.getMockedNgDefOf = exports.isMockOf = exports.isNgModuleDefWithProviders = exports.isNgInjectionToken = exports.isMockedNgDefOf = exports.isNgDef = exports.isNgType = exports.mapEntries = exports.mapValues = exports.mapKeys = exports.flatten = exports.getNgMocksFromTestBed = exports.NG_MOCKS = void 0;
const core_1 = require("@angular/core");
const testing_1 = require("@angular/core/testing");
const ng_mocks_universe_1 = require("./ng-mocks-universe");
const reflect_1 = require("./reflect");
exports.NG_MOCKS = new core_1.InjectionToken('NG_MOCKS');
exports.getNgMocksFromTestBed = () => {
    const testBed = testing_1.getTestBed();
    try {
        return testBed.inject ? testBed.inject(exports.NG_MOCKS) : testBed.get(exports.NG_MOCKS);
    }
    catch (e) {
        return undefined;
    }
};
exports.flatten = (values, result = []) => {
    if (Array.isArray(values)) {
        values.forEach((value) => exports.flatten(value, result));
    }
    else {
        result.push(values);
    }
    return result;
};
exports.mapKeys = (set) => {
    const result = [];
    set.forEach((_, value) => result.push(value));
    return result;
};
exports.mapValues = (set) => {
    const result = [];
    set.forEach((value) => result.push(value));
    return result;
};
exports.mapEntries = (set) => {
    const result = [];
    set.forEach((value, key) => result.push([key, value]));
    return result;
};
exports.isNgType = (object, type) => reflect_1.jitReflector.annotations(object).some(annotation => annotation.ngMetadataName === type);
function isNgDef(object, ngType) {
    if (ngType === 'm') {
        return exports.isNgType(object, 'NgModule');
    }
    if (ngType === 'c') {
        return exports.isNgType(object, 'Component');
    }
    if (ngType === 'd') {
        return exports.isNgType(object, 'Directive');
    }
    if (ngType === 'p') {
        return exports.isNgType(object, 'Pipe');
    }
    return false;
}
exports.isNgDef = isNgDef;
function isMockedNgDefOf(object, type, ngType) {
    return typeof object === 'function' && object.mockOf === type && (ngType ? isNgDef(object, ngType) : true);
}
exports.isMockedNgDefOf = isMockedNgDefOf;
exports.isNgInjectionToken = (object) => typeof object === 'object' && object.ngMetadataName === 'InjectionToken';
exports.isNgModuleDefWithProviders = (object) => object.ngModule !== undefined && isNgDef(object.ngModule, 'm');
function isMockOf(object, type, ngType) {
    return (typeof object === 'object' &&
        (ngType ? isMockedNgDefOf(object.constructor, type, ngType) : isMockedNgDefOf(object.constructor, type)));
}
exports.isMockOf = isMockOf;
function getMockedNgDefOf(type, ngType) {
    const source = type.mockOf ? type.mockOf : type;
    const mocks = exports.getNgMocksFromTestBed();
    let mock;
    if (mocks && mocks.has(source)) {
        mock = mocks.get(source);
    }
    else if (mocks) {
        throw new Error(`There is no mock for ${source.name}`);
    }
    if (!mock && source !== type) {
        mock = type;
    }
    else if (!mock && ng_mocks_universe_1.ngMocksUniverse.cache.has(source)) {
        mock = ng_mocks_universe_1.ngMocksUniverse.cache.get(source);
    }
    if (!ngType) {
        return mock;
    }
    if (ngType && isMockedNgDefOf(mock, type, ngType)) {
        return mock;
    }
    throw new Error(`There is no mock for ${source.name}`);
}
exports.getMockedNgDefOf = getMockedNgDefOf;
function getSourceOfMock(type) {
    return typeof type === 'function' && type.mockOf ? type.mockOf : type;
}
exports.getSourceOfMock = getSourceOfMock;
//# sourceMappingURL=lib.js.map