"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockComponent = exports.MockComponents = void 0;
const core_1 = require("@angular/core");
const testing_1 = require("@angular/core/testing");
const forms_1 = require("@angular/forms");
const common_1 = require("../common");
const decorate_1 = require("../common/decorate");
const ng_mocks_universe_1 = require("../common/ng-mocks-universe");
const reflect_1 = require("../common/reflect");
function MockComponents(...components) {
    return components.map(component => MockComponent(component, undefined));
}
exports.MockComponents = MockComponents;
function MockComponent(component, metaData) {
    if (testing_1.getTestBed()._instantiated) {
        try {
            return common_1.getMockedNgDefOf(component, 'c');
        }
        catch (error) {
        }
    }
    if (ng_mocks_universe_1.ngMocksUniverse.flags.has('cacheComponent') && ng_mocks_universe_1.ngMocksUniverse.cache.has(component)) {
        return ng_mocks_universe_1.ngMocksUniverse.cache.get(component);
    }
    let meta = metaData;
    if (!meta) {
        try {
            meta = reflect_1.directiveResolver.resolve(component);
        }
        catch (e) {
            throw new Error('ng-mocks is not in JIT mode and cannot resolve declarations');
        }
    }
    const { exportAs, inputs, outputs, queries, selector, providers } = meta;
    let template = `<ng-content></ng-content>`;
    const viewChildRefs = new Map();
    if (queries) {
        const queriesKeys = Object.keys(queries);
        const templateQueries = queriesKeys
            .map((key) => {
            const query = queries[key];
            if (query.isViewQuery) {
                return '';
            }
            if (typeof query.selector !== 'string') {
                return '';
            }
            viewChildRefs.set(query.selector, key);
            queries[`__mockView_${key}`] = new core_1.ViewChild(`__${query.selector}`, {
                read: core_1.ViewContainerRef,
                static: false,
            });
            return `
          <div *ngIf="mockRender_${query.selector}" data-key="${query.selector}">
            <ng-template #__${query.selector}></ng-template>
          </div>
        `;
        })
            .join('');
        if (templateQueries) {
            template = `
        ${template}
        ${templateQueries}
      `;
        }
    }
    const options = {
        exportAs,
        providers: [
            {
                provide: component,
                useExisting: core_1.forwardRef(() => ComponentMock),
            },
        ],
        selector,
        template,
    };
    for (const providerDef of common_1.flatten(providers)) {
        const provider = providerDef && typeof providerDef === 'object' && providerDef.provide ? providerDef.provide : providerDef;
        if (options.providers && provider === forms_1.NG_VALUE_ACCESSOR) {
            options.providers.push({
                multi: true,
                provide: forms_1.NG_VALUE_ACCESSOR,
                useExisting: core_1.forwardRef(() => ComponentMock),
            });
        }
        if (options.providers && provider === forms_1.NG_VALIDATORS) {
            options.providers.push({
                multi: true,
                provide: forms_1.NG_VALIDATORS,
                useExisting: core_1.forwardRef(() => ComponentMock),
            });
        }
    }
    const config = ng_mocks_universe_1.ngMocksUniverse.config.get(component);
    let ComponentMock = class ComponentMock extends common_1.MockControlValueAccessor {
        constructor(changeDetector) {
            super();
            this.__hide = (contentChildSelector) => {
                const key = viewChildRefs.get(contentChildSelector);
                if (key) {
                    this[`mockRender_${contentChildSelector}`] = false;
                    changeDetector.detectChanges();
                }
            };
            this.__render = (contentChildSelector, $implicit, variables) => {
                const key = viewChildRefs.get(contentChildSelector);
                let templateRef;
                let viewContainer;
                if (key) {
                    this[`mockRender_${contentChildSelector}`] = true;
                    changeDetector.detectChanges();
                    viewContainer = this[`__mockView_${key}`];
                    templateRef = this[key];
                    if (viewContainer && templateRef) {
                        viewContainer.clear();
                        viewContainer.createEmbeddedView(templateRef, Object.assign(Object.assign({}, variables), { $implicit }));
                        changeDetector.detectChanges();
                    }
                }
            };
        }
        ngAfterContentInit() {
            if (!this.__rendered && config && config.render) {
                for (const block of Object.keys(config.render)) {
                    const { $implicit, variables } = config.render[block] !== true
                        ? config.render[block]
                        : {
                            $implicit: undefined,
                            variables: {},
                        };
                    this.__render(block, $implicit, variables);
                }
                this.__rendered = true;
            }
        }
    };
    ComponentMock = __decorate([
        core_1.Component(options),
        common_1.MockOf(component, outputs),
        __metadata("design:paramtypes", [core_1.ChangeDetectorRef])
    ], ComponentMock);
    decorate_1.decorateInputs(ComponentMock, inputs);
    decorate_1.decorateOutputs(ComponentMock, outputs);
    decorate_1.decorateQueries(ComponentMock, queries);
    if (ng_mocks_universe_1.ngMocksUniverse.flags.has('cacheComponent')) {
        ng_mocks_universe_1.ngMocksUniverse.cache.set(component, ComponentMock);
    }
    return ComponentMock;
}
exports.MockComponent = MockComponent;
//# sourceMappingURL=mock-component.js.map