"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockBuilder = exports.MockBuilderPromise = void 0;
const testing_1 = require("@angular/core/testing");
const common_1 = require("../common");
const ng_mocks_universe_1 = require("../common/ng-mocks-universe");
const mock_component_1 = require("../mock-component");
const mock_directive_1 = require("../mock-directive");
const mock_module_1 = require("../mock-module");
const mock_pipe_1 = require("../mock-pipe");
const defaultMock = {};
class MockBuilderPromise {
    constructor() {
        this.beforeCC = new Set();
        this.configDef = new Map();
        this.keepDef = {
            component: new Set(),
            directive: new Set(),
            module: new Set(),
            pipe: new Set(),
            provider: new Set(),
        };
        this.mockDef = {
            component: new Set(),
            directive: new Set(),
            module: new Set(),
            pipe: new Set(),
            pipeTransform: new Map(),
            provider: new Set(),
            providerMock: new Map(),
        };
        this.providerDef = new Map();
        this.replaceDef = {
            component: new Map(),
            directive: new Map(),
            module: new Map(),
            pipe: new Map(),
        };
    }
    beforeCompileComponents(callback) {
        this.beforeCC.add(callback);
        return this;
    }
    build() {
        const backup = {
            builder: ng_mocks_universe_1.ngMocksUniverse.builder,
            cache: ng_mocks_universe_1.ngMocksUniverse.cache,
            config: ng_mocks_universe_1.ngMocksUniverse.config,
            flags: ng_mocks_universe_1.ngMocksUniverse.flags,
            touches: ng_mocks_universe_1.ngMocksUniverse.touches,
        };
        ng_mocks_universe_1.ngMocksUniverse.builder = new Map();
        ng_mocks_universe_1.ngMocksUniverse.cache = new Map();
        ng_mocks_universe_1.ngMocksUniverse.config = this.configDef;
        ng_mocks_universe_1.ngMocksUniverse.flags = new Set([
            'cacheComponent',
            'cacheDirective',
            'cacheModule',
            'cachePipe',
            'cacheProvider',
            'correctModuleExports',
        ]);
        ng_mocks_universe_1.ngMocksUniverse.touches = new Set();
        for (const def of [
            ...common_1.mapValues(this.keepDef.provider),
            ...common_1.mapValues(this.keepDef.pipe),
            ...common_1.mapValues(this.keepDef.directive),
            ...common_1.mapValues(this.keepDef.component),
            ...common_1.mapValues(this.keepDef.module),
        ]) {
            ng_mocks_universe_1.ngMocksUniverse.builder.set(def, def);
        }
        for (const [source, destination] of [
            ...common_1.mapEntries(this.replaceDef.pipe),
            ...common_1.mapEntries(this.replaceDef.directive),
            ...common_1.mapEntries(this.replaceDef.component),
            ...common_1.mapEntries(this.replaceDef.module),
        ]) {
            ng_mocks_universe_1.ngMocksUniverse.builder.set(source, destination);
        }
        for (const def of common_1.mapValues(this.mockDef.provider)) {
            if (this.mockDef.providerMock.has(def)) {
                ng_mocks_universe_1.ngMocksUniverse.builder.set(def, { provide: def, useValue: this.mockDef.providerMock.get(def) });
            }
            else {
                ng_mocks_universe_1.ngMocksUniverse.builder.set(def, mock_module_1.MockProvider(def));
            }
            ng_mocks_universe_1.ngMocksUniverse.touches.delete(def);
        }
        for (const def of common_1.mapValues(this.mockDef.pipe)) {
            if (this.mockDef.pipeTransform.has(def)) {
                ng_mocks_universe_1.ngMocksUniverse.builder.set(def, mock_pipe_1.MockPipe(def, this.mockDef.pipeTransform.get(def)));
            }
            else {
                ng_mocks_universe_1.ngMocksUniverse.builder.set(def, mock_pipe_1.MockPipe(def));
            }
            ng_mocks_universe_1.ngMocksUniverse.touches.delete(def);
        }
        for (const def of common_1.mapValues(this.mockDef.directive)) {
            ng_mocks_universe_1.ngMocksUniverse.builder.set(def, mock_directive_1.MockDirective(def));
            ng_mocks_universe_1.ngMocksUniverse.touches.delete(def);
        }
        for (const def of common_1.mapValues(this.mockDef.component)) {
            ng_mocks_universe_1.ngMocksUniverse.builder.set(def, mock_component_1.MockComponent(def));
            ng_mocks_universe_1.ngMocksUniverse.touches.delete(def);
        }
        for (const def of [
            ...common_1.mapValues(this.mockDef.module),
            ...common_1.mapValues(this.keepDef.module),
            ...common_1.mapKeys(this.replaceDef.module),
        ]) {
            ng_mocks_universe_1.ngMocksUniverse.builder.set(def, mock_module_1.MockModule(def));
            ng_mocks_universe_1.ngMocksUniverse.touches.delete(def);
        }
        const imports = [];
        for (const def of [
            ...common_1.mapValues(this.mockDef.module),
            ...common_1.mapValues(this.keepDef.module),
            ...common_1.mapKeys(this.replaceDef.module),
        ]) {
            if (ng_mocks_universe_1.ngMocksUniverse.touches.has(def)) {
                continue;
            }
            const config = this.configDef.get(def);
            if (config && config.dependency) {
                continue;
            }
            imports.push(ng_mocks_universe_1.ngMocksUniverse.builder.get(def));
        }
        const declarations = [];
        for (const def of [
            ...common_1.mapValues(this.keepDef.pipe),
            ...common_1.mapValues(this.keepDef.directive),
            ...common_1.mapValues(this.keepDef.component),
            ...common_1.mapKeys(this.replaceDef.pipe),
            ...common_1.mapKeys(this.replaceDef.directive),
            ...common_1.mapKeys(this.replaceDef.component),
            ...common_1.mapValues(this.mockDef.pipe),
            ...common_1.mapValues(this.mockDef.directive),
            ...common_1.mapValues(this.mockDef.component),
        ]) {
            if (ng_mocks_universe_1.ngMocksUniverse.touches.has(def)) {
                continue;
            }
            const config = this.configDef.get(def);
            if (config && config.dependency) {
                continue;
            }
            declarations.push(ng_mocks_universe_1.ngMocksUniverse.builder.get(def));
        }
        const providers = [];
        for (const def of common_1.mapValues(this.keepDef.provider)) {
            if (ng_mocks_universe_1.ngMocksUniverse.touches.has(def)) {
                continue;
            }
            const config = this.configDef.get(def);
            if (config && config.dependency) {
                continue;
            }
            if (common_1.isNgInjectionToken(def)) {
                continue;
            }
            providers.push(def);
        }
        for (const def of common_1.mapValues(this.mockDef.provider)) {
            if (ng_mocks_universe_1.ngMocksUniverse.touches.has(def)) {
                continue;
            }
            const config = this.configDef.get(def);
            if (config && config.dependency) {
                continue;
            }
            const mock = ng_mocks_universe_1.ngMocksUniverse.builder.get(def);
            providers.push(mock
                ? mock
                : {
                    provide: def,
                    useValue: undefined,
                });
        }
        for (const provider of common_1.mapValues(this.providerDef)) {
            if (!provider) {
                continue;
            }
            providers.push(provider);
        }
        const ngMocks = new Map();
        for (const [key, value] of [...common_1.mapEntries(ng_mocks_universe_1.ngMocksUniverse.builder), ...common_1.mapEntries(ng_mocks_universe_1.ngMocksUniverse.cache)]) {
            ngMocks.set(key, value);
        }
        providers.push({
            provide: common_1.NG_MOCKS,
            useValue: ngMocks,
        });
        for (const key of Object.keys(backup)) {
            ng_mocks_universe_1.ngMocksUniverse[key] = backup[key];
        }
        return {
            declarations,
            imports,
            providers,
        };
    }
    keep(def, config) {
        if (common_1.isNgDef(def, 'm')) {
            this.mockDef.module.delete(def);
            this.replaceDef.module.delete(def);
            this.keepDef.module.add(def);
        }
        else if (common_1.isNgDef(def, 'c')) {
            this.mockDef.component.delete(def);
            this.replaceDef.component.delete(def);
            this.keepDef.component.add(def);
        }
        else if (common_1.isNgDef(def, 'd')) {
            this.mockDef.directive.delete(def);
            this.replaceDef.directive.delete(def);
            this.keepDef.directive.add(def);
        }
        else if (common_1.isNgDef(def, 'p')) {
            this.mockDef.pipe.delete(def);
            this.mockDef.pipeTransform.delete(def);
            this.replaceDef.pipe.delete(def);
            this.keepDef.pipe.add(def);
        }
        else {
            this.mockDef.provider.delete(def);
            this.mockDef.providerMock.delete(def);
            this.providerDef.delete(def);
            this.keepDef.provider.add(def);
        }
        if (config) {
            this.configDef.set(def, config);
        }
        else {
            this.configDef.delete(def);
        }
        return this;
    }
    mock(def, a1 = defaultMock, a2) {
        let mock = a1;
        let config = a1 === defaultMock ? undefined : a1;
        if (common_1.isNgDef(def, 'p') && typeof a1 === 'function') {
            mock = a1;
            config = a2;
        }
        if (common_1.isNgDef(def, 'm')) {
            this.keepDef.module.delete(def);
            this.replaceDef.module.delete(def);
            this.mockDef.module.add(def);
        }
        else if (common_1.isNgDef(def, 'c')) {
            this.keepDef.component.delete(def);
            this.replaceDef.component.delete(def);
            this.mockDef.component.add(def);
        }
        else if (common_1.isNgDef(def, 'd')) {
            this.keepDef.directive.delete(def);
            this.replaceDef.directive.delete(def);
            this.mockDef.directive.add(def);
        }
        else if (common_1.isNgDef(def, 'p')) {
            this.keepDef.pipe.delete(def);
            this.replaceDef.pipe.delete(def);
            this.mockDef.pipe.add(def);
            if (typeof mock === 'function') {
                this.mockDef.pipeTransform.set(def, mock);
            }
        }
        else {
            this.keepDef.provider.delete(def);
            this.providerDef.delete(def);
            this.mockDef.provider.add(def);
            if (mock !== defaultMock) {
                this.mockDef.providerMock.set(def, mock);
            }
            config = undefined;
        }
        if (config) {
            this.configDef.set(def, config);
        }
        else {
            this.configDef.delete(def);
        }
        return this;
    }
    provide(def) {
        for (const provider of common_1.flatten(def)) {
            const provide = typeof provider === 'object' && provider.provide ? provider.provide : provider;
            const multi = typeof provider === 'object' && provider.provide && provider.multi;
            this.keepDef.provider.delete(provide);
            this.mockDef.provider.delete(provide);
            const existing = this.providerDef.has(provide) ? this.providerDef.get(provide) : [];
            this.providerDef.set(provide, multi ? [...(Array.isArray(existing) ? existing : []), provider] : provider);
        }
        return this;
    }
    replace(source, destination, config) {
        if (common_1.isNgDef(source, 'm') && common_1.isNgDef(destination, 'm')) {
            this.keepDef.module.delete(source);
            this.mockDef.module.delete(source);
            this.replaceDef.module.set(source, destination);
        }
        else if (common_1.isNgDef(source, 'c') && common_1.isNgDef(destination, 'c')) {
            this.keepDef.component.delete(source);
            this.mockDef.component.delete(source);
            this.replaceDef.component.set(source, destination);
        }
        else if (common_1.isNgDef(source, 'd') && common_1.isNgDef(destination, 'd')) {
            this.keepDef.directive.delete(source);
            this.mockDef.directive.delete(source);
            this.replaceDef.directive.set(source, destination);
        }
        else if (common_1.isNgDef(source, 'p') && common_1.isNgDef(destination, 'p')) {
            this.keepDef.pipe.delete(source);
            this.mockDef.pipe.delete(source);
            this.replaceDef.pipe.set(source, destination);
        }
        else {
            throw new Error('cannot replace the source by destination destination, wrong types');
        }
        if (config) {
            this.configDef.set(source, config);
        }
        else {
            this.configDef.delete(source);
        }
        return this;
    }
    then(fulfill, reject) {
        const promise = new Promise((resolve) => {
            const testBed = testing_1.TestBed.configureTestingModule(this.build());
            for (const callback of common_1.mapValues(this.beforeCC)) {
                callback(testBed);
            }
            testBed.compileComponents().then(() => {
                resolve({ testBed });
            });
        });
        return promise.then(fulfill, reject);
    }
}
exports.MockBuilderPromise = MockBuilderPromise;
function MockBuilder(componentToTest, itsModuleToMock) {
    const instance = new MockBuilderPromise();
    if (componentToTest) {
        instance.keep(componentToTest, {
            export: true,
        });
    }
    if (itsModuleToMock) {
        instance.mock(itsModuleToMock);
    }
    return instance;
}
exports.MockBuilder = MockBuilder;
//# sourceMappingURL=mock-builder.js.map