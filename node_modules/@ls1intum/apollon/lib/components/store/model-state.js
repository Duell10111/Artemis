"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var uml_elements_1 = require("../../packages/uml-elements");
var uml_relationships_1 = require("../../packages/uml-relationships");
var uml_container_1 = require("../../services/uml-container/uml-container");
var uml_element_1 = require("../../services/uml-element/uml-element");
var uml_element_repository_1 = require("../../services/uml-element/uml-element-repository");
var uml_relationship_1 = require("../../services/uml-relationship/uml-relationship");
var uml_relationship_repository_1 = require("../../services/uml-relationship/uml-relationship-repository");
var boundary_1 = require("../../utils/geometry/boundary");
var uml_diagram_1 = require("../../services/uml-diagram/uml-diagram");
var ModelState = /** @class */ (function () {
    function ModelState() {
    }
    ModelState.fromModel = function (model) {
        var e_1, _a;
        var apollonElements = model.elements;
        var apollonRelationships = model.relationships;
        var deserialize = function (apollonElement) {
            var element = new uml_elements_1.UMLElements[apollonElement.type]();
            var children = uml_container_1.UMLContainer.isUMLContainer(element)
                ? apollonElements
                    .filter(function (child) { return child.owner === apollonElement.id; })
                    .map(function (val) {
                    var parent = apollonElements.find(function (e) { return e.id === val.owner; });
                    return tslib_1.__assign(tslib_1.__assign({}, val), { bounds: tslib_1.__assign(tslib_1.__assign({}, val.bounds), { x: val.bounds.x - parent.bounds.x, y: val.bounds.y - parent.bounds.y }) });
                })
                : [];
            element.deserialize(apollonElement, children);
            return tslib_1.__spread([element], children.reduce(function (acc, val) { return tslib_1.__spread(acc, deserialize(val)); }, []));
        };
        var elements = apollonElements
            .filter(function (element) { return !element.owner; })
            .reduce(function (acc, val) { return tslib_1.__spread(acc, deserialize(val)); }, []);
        var relationships = apollonRelationships.map(function (apollonRelationship) {
            var relationship = new uml_relationships_1.UMLRelationships[apollonRelationship.type]();
            relationship.deserialize(apollonRelationship);
            return relationship;
        });
        var roots = tslib_1.__spread(elements.filter(function (element) { return !element.owner; }), relationships);
        var bounds = boundary_1.computeBoundingBoxForElements(roots);
        bounds.width = Math.ceil(bounds.width / 20) * 20;
        bounds.height = Math.ceil(bounds.height / 20) * 20;
        try {
            for (var roots_1 = tslib_1.__values(roots), roots_1_1 = roots_1.next(); !roots_1_1.done; roots_1_1 = roots_1.next()) {
                var element = roots_1_1.value;
                element.bounds.x -= bounds.x + bounds.width / 2;
                element.bounds.y -= bounds.y + bounds.height / 2;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (roots_1_1 && !roots_1_1.done && (_a = roots_1.return)) _a.call(roots_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        // set diagram to keep diagram type
        var diagram = new uml_diagram_1.UMLDiagram();
        diagram.type = model.type;
        return {
            diagram: diagram,
            interactive: tslib_1.__spread(model.interactive.elements, model.interactive.relationships),
            elements: tslib_1.__spread(elements, relationships).reduce(function (acc, val) {
                var _a;
                return (tslib_1.__assign(tslib_1.__assign({}, acc), (_a = {}, _a[val.id] = tslib_1.__assign({}, val), _a)));
            }, {}),
            assessments: (model.assessments || []).reduce(function (acc, val) {
                var _a;
                return (tslib_1.__assign(tslib_1.__assign({}, acc), (_a = {}, _a[val.modelElementId] = { score: val.score, feedback: val.feedback }, _a)));
            }, {}),
        };
    };
    ModelState.toModel = function (state) {
        var e_2, _a, e_3, _b;
        var elements = Object.values(state.elements)
            .map(function (element) { return uml_element_repository_1.UMLElementRepository.get(element); })
            .reduce(function (acc, val) {
            var _a;
            return (tslib_1.__assign(tslib_1.__assign({}, acc), (val && (_a = {}, _a[val.id] = val, _a))));
        }, {});
        var relationships = Object.values(state.elements)
            .filter(function (x) { return uml_relationship_1.UMLRelationship.isUMLRelationship(x); })
            .map(function (relationship) { return uml_relationship_repository_1.UMLRelationshipRepository.get(relationship); });
        var serialize = function (element) {
            var children = uml_container_1.UMLContainer.isUMLContainer(element)
                ? element.ownedElements.map(function (id) { return elements[id]; })
                : [];
            return tslib_1.__spread([
                element.serialize(children)
            ], children
                .reduce(function (acc, val) { return tslib_1.__spread(acc, serialize(val)); }, [])
                .map(function (val) { return (tslib_1.__assign(tslib_1.__assign({}, val), { bounds: tslib_1.__assign(tslib_1.__assign({}, val.bounds), { x: val.bounds.x + element.bounds.x, y: val.bounds.y + element.bounds.y }) })); }));
        };
        var apollonElements = Object.values(elements)
            .filter(function (element) { return !element.owner; })
            .reduce(function (acc, val) { return tslib_1.__spread(acc, serialize(val)); }, []);
        var apollonRelationships = relationships.map(function (relationship) { return relationship.serialize(); });
        var roots = tslib_1.__spread(apollonElements, apollonRelationships).filter(function (element) { return !element.owner; });
        var bounds = boundary_1.computeBoundingBoxForElements(roots);
        bounds.width = Math.ceil(bounds.width / 20) * 20;
        bounds.height = Math.ceil(bounds.height / 20) * 20;
        try {
            for (var apollonElements_1 = tslib_1.__values(apollonElements), apollonElements_1_1 = apollonElements_1.next(); !apollonElements_1_1.done; apollonElements_1_1 = apollonElements_1.next()) {
                var element = apollonElements_1_1.value;
                element.bounds.x -= bounds.x;
                element.bounds.y -= bounds.y;
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (apollonElements_1_1 && !apollonElements_1_1.done && (_a = apollonElements_1.return)) _a.call(apollonElements_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        try {
            for (var apollonRelationships_1 = tslib_1.__values(apollonRelationships), apollonRelationships_1_1 = apollonRelationships_1.next(); !apollonRelationships_1_1.done; apollonRelationships_1_1 = apollonRelationships_1.next()) {
                var element = apollonRelationships_1_1.value;
                element.bounds.x -= bounds.x;
                element.bounds.y -= bounds.y;
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (apollonRelationships_1_1 && !apollonRelationships_1_1.done && (_b = apollonRelationships_1.return)) _b.call(apollonRelationships_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
        var interactive = {
            elements: state.interactive.filter(function (id) { return uml_element_1.UMLElement.isUMLElement(state.elements[id]); }),
            relationships: state.interactive.filter(function (id) { return uml_relationship_1.UMLRelationship.isUMLRelationship(state.elements[id]); }),
        };
        var assessments = Object.keys(state.assessments).map(function (id) { return ({
            modelElementId: id,
            elementType: state.elements[id].type,
            score: state.assessments[id].score,
            feedback: state.assessments[id].feedback,
        }); });
        return {
            version: '2.0.0',
            type: state.diagram.type,
            size: { width: state.diagram.bounds.width, height: state.diagram.bounds.height },
            interactive: interactive,
            elements: apollonElements,
            relationships: apollonRelationships,
            assessments: assessments,
        };
    };
    return ModelState;
}());
exports.ModelState = ModelState;
//# sourceMappingURL=model-state.js.map