"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var react_1 = tslib_1.__importStar(require("react"));
var react_dom_1 = require("react-dom");
var point_1 = require("../../utils/geometry/point");
var with_canvas_1 = require("../canvas/with-canvas");
var draggable_context_1 = require("./draggable-context");
var ghost_1 = require("./ghost");
var redux_1 = require("redux");
var with_root_1 = require("../root/with-root");
var initialState = {
    dragging: false,
    offset: new point_1.Point(),
    position: new point_1.Point(),
    resolve: null,
    reject: null,
};
var enhance = redux_1.compose(with_canvas_1.withCanvas, with_root_1.withRoot);
var DraggableLayerComponent = /** @class */ (function (_super) {
    tslib_1.__extends(DraggableLayerComponent, _super);
    function DraggableLayerComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = initialState;
        _this.ghost = react_1.createRef();
        _this.onDragStart = function (event) {
            var element = event.currentTarget;
            var bounds = element.getBoundingClientRect();
            var rootBounds = _this.props.root.getBoundingClientRect();
            // bounds.left - rooBounds.x => position to origin
            // one could delete event.pageX (a - a = 0)in for this case, but its is important to calculate the offset correctly for moving event
            var offset = new point_1.Point(event.pageX - (bounds.left - rootBounds.x), event.pageY - (bounds.top - rootBounds.y));
            var position = new point_1.Point(event.pageX - offset.x, event.pageY - offset.y);
            document.addEventListener('pointermove', _this.onPointerMove);
            document.addEventListener('pointerup', _this.cancel, { once: true });
            return new Promise(function (resolve, reject) {
                return _this.setState({ dragging: true, offset: offset, position: position, resolve: resolve, reject: reject }, function () {
                    var container = _this.ghost.current;
                    container.append(element.cloneNode(true));
                });
            });
        };
        _this.onPointerMove = function (event) {
            var position = new point_1.Point(event.pageX - _this.state.offset.x, event.pageY - _this.state.offset.y);
            _this.setState({ position: position });
        };
        _this.onDragEnd = function (owner) { return function (event) {
            if (!_this.state.dragging)
                return;
            var dropEvent = {
                owner: owner,
                // transformation to new relational point origin, which is in the center of the canvas
                position: _this.state.position.subtract(_this.props.canvas
                    .origin()
                    .subtract(_this.props.root.getBoundingClientRect().x, _this.props.root.getBoundingClientRect().y)),
            };
            if (_this.state.resolve) {
                _this.state.resolve(dropEvent);
            }
        }; };
        _this.cancel = function () {
            if (_this.state.reject) {
                _this.state.reject();
            }
            document.removeEventListener('pointermove', _this.onPointerMove);
            _this.setState(initialState);
        };
        return _this;
    }
    DraggableLayerComponent.prototype.render = function () {
        var context = {
            onDragStart: this.onDragStart,
            onDragEnd: this.onDragEnd,
        };
        var _a = this.state, dragging = _a.dragging, position = _a.position;
        return (react_1.default.createElement(draggable_context_1.DraggableProvider, { value: context },
            this.props.children,
            react_dom_1.createPortal(dragging && react_1.default.createElement(ghost_1.Ghost, { ref: this.ghost, position: position }), this.props.root)));
    };
    return DraggableLayerComponent;
}(react_1.Component));
exports.DraggableLayer = enhance(DraggableLayerComponent);
//# sourceMappingURL=draggable-layer.js.map