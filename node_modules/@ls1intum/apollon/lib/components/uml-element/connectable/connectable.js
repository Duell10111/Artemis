"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var react_1 = tslib_1.__importStar(require("react"));
var react_dom_1 = require("react-dom");
var react_redux_1 = require("react-redux");
var uml_element_port_1 = require("../../../services/uml-element/uml-element-port");
var uml_element_repository_1 = require("../../../services/uml-element/uml-element-repository");
var uml_relationship_repository_1 = require("../../../services/uml-relationship/uml-relationship-repository");
var point_1 = require("../../../utils/geometry/point");
var styles_1 = require("../../theme/styles");
var uml_elements_1 = require("../../../packages/uml-elements");
var uml_relationships_1 = require("../../../packages/uml-relationships");
var enhance = react_redux_1.connect(function (state, props) { return ({
    hovered: state.hovered[0] === props.id,
    selected: state.selected.includes(props.id),
    connecting: !!state.connecting.length,
    reconnecting: !!Object.keys(state.reconnecting).length,
    ports: uml_element_repository_1.UMLElementRepository.get(state.elements[props.id]).ports(),
    type: state.elements[props.id].type,
}); }, {
    start: uml_element_repository_1.UMLElementRepository.startConnecting,
    connect: uml_element_repository_1.UMLElementRepository.connect,
    reconnect: uml_relationship_repository_1.UMLRelationshipRepository.reconnect,
});
// alternative port visualization size
var alternativePortHeight = 10;
var alternativePortWidth = 5;
var alternativePortCircleSize = 30;
// default port visualization size
var defaultPortSize = 20;
var Handle = styles_1.styled(function (props) {
    var alternativePortVisualization = props.alternativePortVisualization, otherProps = tslib_1.__rest(props, ["alternativePortVisualization"]);
    if (alternativePortVisualization) {
        return (react_1.default.createElement("svg", tslib_1.__assign({}, otherProps),
            react_1.default.createElement("path", { d: "M " + alternativePortWidth / 2 + " 0 v -" + alternativePortHeight + " h -" + alternativePortWidth + " v " + alternativePortHeight + " Z" }),
            react_1.default.createElement("path", { d: "M -" + alternativePortCircleSize / 2 + " -" + (alternativePortHeight + alternativePortCircleSize / 2) +
                    (" a " + alternativePortCircleSize / 2 + " " + alternativePortCircleSize / 2 + " 0 0 1 " + alternativePortCircleSize + " 0") +
                    (" a " + alternativePortCircleSize / 2 + " " + alternativePortCircleSize / 2 + " 0 0 1 -" + alternativePortCircleSize + " 0") })));
    }
    else {
        return (react_1.default.createElement("svg", tslib_1.__assign({}, otherProps),
            react_1.default.createElement("path", { d: "M -" + defaultPortSize + " 0 A " + defaultPortSize / 2 + " " + defaultPortSize / 2 + " 0 0 1 " + defaultPortSize + " 0" })));
    }
}).attrs(function (_a) {
    var direction = _a.direction, ports = _a.ports;
    return ({
        fill: '#0064ff',
        fillOpacity: 0.2,
        x: ports[direction].x + "px",
        y: ports[direction].y + "px",
        rotate: direction === uml_element_port_1.Direction.Up ? 0 : direction === uml_element_port_1.Direction.Right ? 90 : direction === uml_element_port_1.Direction.Down ? 180 : -90,
    });
})(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject(["\n  cursor: crosshair;\n  pointer-events: all;\n\n  path {\n    transform: rotate(", "deg);\n  }\n"], ["\n  cursor: crosshair;\n  pointer-events: all;\n\n  path {\n    transform: rotate(", "deg);\n  }\n"])), function (props) { return props.rotate; });
exports.connectable = function (WrappedComponent) {
    var Connectable = /** @class */ (function (_super) {
        tslib_1.__extends(Connectable, _super);
        function Connectable() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.elementOnPointerUp = function (event) {
                var _a;
                var node = react_dom_1.findDOMNode(_this);
                // calculate event position relative to object position in %
                var nodeRect = node.getBoundingClientRect();
                var relEventPosition = {
                    x: (event.clientX - nodeRect.left) / nodeRect.width,
                    y: (event.clientY - nodeRect.top) / nodeRect.height,
                };
                // relative port locations in %
                var relativePortLocation = (_a = {},
                    _a[uml_element_port_1.Direction.Up] = new point_1.Point(0.5, 0),
                    _a[uml_element_port_1.Direction.Right] = new point_1.Point(1, 0.5),
                    _a[uml_element_port_1.Direction.Down] = new point_1.Point(0.5, 1),
                    _a[uml_element_port_1.Direction.Left] = new point_1.Point(0, 0.5),
                    _a);
                // calculate the distances to all handles
                var distances = Object.entries(_this.props.ports).map(function (_a) {
                    var _b = tslib_1.__read(_a, 2), key = _b[0], value = _b[1];
                    return ({
                        key: key,
                        distance: Math.sqrt(Math.pow(relativePortLocation[key].x - relEventPosition.x, 2) +
                            Math.pow(relativePortLocation[key].y - relEventPosition.y, 2)),
                    });
                });
                // use handle with min distance to connect to
                var minDistance = Math.min.apply(Math, tslib_1.__spread(distances.map(function (value) { return value.distance; })));
                var direction = distances.filter(function (value) { return minDistance === value.distance; })[0].key;
                if (_this.props.connecting) {
                    _this.props.connect({ element: _this.props.id, direction: direction });
                }
                if (_this.props.reconnecting) {
                    _this.props.reconnect({ element: _this.props.id, direction: direction });
                }
            };
            _this.onPointerDown = function (event) {
                var direction = event.currentTarget.getAttribute('direction');
                _this.props.start(direction);
            };
            _this.onPointerUp = function (event) {
                var direction = event.currentTarget.getAttribute('direction');
                if (_this.props.connecting) {
                    _this.props.connect({ element: _this.props.id, direction: direction });
                }
                if (_this.props.reconnecting) {
                    _this.props.reconnect({ element: _this.props.id, direction: direction });
                }
            };
            return _this;
        }
        Connectable.prototype.componentDidMount = function () {
            var node = react_dom_1.findDOMNode(this);
            node.addEventListener('pointerup', this.elementOnPointerUp.bind(this));
        };
        Connectable.prototype.componentWillUnmount = function () {
            var node = react_dom_1.findDOMNode(this);
            node.removeEventListener('pointerup', this.elementOnPointerUp);
        };
        Connectable.prototype.render = function () {
            var _a = this.props, hovered = _a.hovered, selected = _a.selected, connecting = _a.connecting, reconnecting = _a.reconnecting, ports = _a.ports, start = _a.start, _ = _a.connect, reconnect = _a.reconnect, type = _a.type, props = tslib_1.__rest(_a, ["hovered", "selected", "connecting", "reconnecting", "ports", "start", "connect", "reconnect", "type"]);
            var features = tslib_1.__assign(tslib_1.__assign({}, uml_elements_1.UMLElements), uml_relationships_1.UMLRelationships)[type].features;
            return (react_1.default.createElement(WrappedComponent, tslib_1.__assign({}, props),
                props.children,
                (hovered || selected || connecting || reconnecting) && (react_1.default.createElement(react_1.default.Fragment, null,
                    react_1.default.createElement(Handle, { ports: ports, direction: uml_element_port_1.Direction.Up, onPointerDown: this.onPointerDown, onPointerUp: this.onPointerUp, alternativePortVisualization: features.alternativePortVisualization }),
                    react_1.default.createElement(Handle, { ports: ports, direction: uml_element_port_1.Direction.Right, onPointerDown: this.onPointerDown, onPointerUp: this.onPointerUp, alternativePortVisualization: features.alternativePortVisualization }),
                    react_1.default.createElement(Handle, { ports: ports, direction: uml_element_port_1.Direction.Down, onPointerDown: this.onPointerDown, onPointerUp: this.onPointerUp, alternativePortVisualization: features.alternativePortVisualization }),
                    react_1.default.createElement(Handle, { ports: ports, direction: uml_element_port_1.Direction.Left, onPointerDown: this.onPointerDown, onPointerUp: this.onPointerUp, alternativePortVisualization: features.alternativePortVisualization })))));
        };
        return Connectable;
    }(react_1.Component));
    return enhance(Connectable);
};
var templateObject_1;
//# sourceMappingURL=connectable.js.map