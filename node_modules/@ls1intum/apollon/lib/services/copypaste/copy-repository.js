"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var tree_1 = require("../../utils/geometry/tree");
var not_empty_1 = require("../../utils/not-empty");
var uml_element_repository_1 = require("../uml-element/uml-element-repository");
var CopyRepository = /** @class */ (function () {
    function CopyRepository() {
    }
    /**
     * Counts how often paste commands are executed to set offset
     */
    CopyRepository.pasteCounter = 0;
    CopyRepository.copy = function (id) { return function (dispatch, getState) {
        CopyRepository.pasteCounter = 0;
        var _a = getState(), elements = _a.elements, selected = _a.selected;
        var ids = id ? (Array.isArray(id) ? id : [id]) : selected;
        // copy elements with all their child elements, because containers do not know their full children representation
        var idsToClone = tree_1.getChildren(ids, getState().elements);
        var result = idsToClone.map(function (id) { return uml_element_repository_1.UMLElementRepository.get(elements[id]); }).filter(not_empty_1.notEmpty);
        navigator.clipboard.writeText(JSON.stringify(result));
    }; };
    CopyRepository.paste = function () { return function (dispatch, getState) {
        CopyRepository.pasteCounter++;
        navigator.clipboard
            .readText()
            .then(function (value) {
            var parsedElements = JSON.parse(value);
            var diagramElements = parsedElements.map(function (x) { return uml_element_repository_1.UMLElementRepository.get(x); }).filter(not_empty_1.notEmpty);
            // roots in diagram Elements
            var roots = diagramElements.filter(function (element) { return !element.owner || diagramElements.every(function (innerElement) { return innerElement.id !== element.owner; }); });
            // flat map elements to copies
            var copies = roots.reduce(function (clonedElements, element) {
                element.owner = null;
                element.bounds.x = element.bounds.x + 10 * CopyRepository.pasteCounter;
                element.bounds.y = element.bounds.y + 10 * CopyRepository.pasteCounter;
                var clones = tree_1.clone(element, diagramElements);
                return clonedElements.concat.apply(clonedElements, tslib_1.__spread(clones));
            }, []);
            // map elements to serializable elements
            return copies.map(function (element) { return (tslib_1.__assign({}, element)); });
        })
            .then(function (elements) {
            dispatch(uml_element_repository_1.UMLElementRepository.create(elements));
            dispatch(uml_element_repository_1.UMLElementRepository.deselect());
            dispatch(uml_element_repository_1.UMLElementRepository.select(tree_1.filterRoots(elements.map(function (element) { return element.id; }), getState().elements)));
        });
    }; };
    return CopyRepository;
}());
exports.CopyRepository = CopyRepository;
//# sourceMappingURL=copy-repository.js.map