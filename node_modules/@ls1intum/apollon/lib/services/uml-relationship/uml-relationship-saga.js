"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var effects_1 = require("redux-saga/effects");
var sagas_1 = require("../../utils/actions/sagas");
var diff_1 = require("../../utils/fx/diff");
var uml_element_repository_1 = require("../uml-element/uml-element-repository");
var uml_relationship_1 = require("./uml-relationship");
var uml_relationship_repository_1 = require("./uml-relationship-repository");
function UMLRelationshipSaga() {
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, sagas_1.run([create, reconnect, update, layoutElement, deleteElement])];
            case 1:
                _a.sent();
                return [2 /*return*/];
        }
    });
}
exports.UMLRelationshipSaga = UMLRelationshipSaga;
function create() {
    var action, _a, _b, value, e_1_1;
    var e_1, _c;
    return tslib_1.__generator(this, function (_d) {
        switch (_d.label) {
            case 0: return [4 /*yield*/, effects_1.take("@@element/CREATE" /* CREATE */)];
            case 1:
                action = _d.sent();
                _d.label = 2;
            case 2:
                _d.trys.push([2, 7, 8, 9]);
                _a = tslib_1.__values(action.payload.values), _b = _a.next();
                _d.label = 3;
            case 3:
                if (!!_b.done) return [3 /*break*/, 6];
                value = _b.value;
                return [4 /*yield*/, effects_1.call(recalc, value.id)];
            case 4:
                _d.sent();
                _d.label = 5;
            case 5:
                _b = _a.next();
                return [3 /*break*/, 3];
            case 6: return [3 /*break*/, 9];
            case 7:
                e_1_1 = _d.sent();
                e_1 = { error: e_1_1 };
                return [3 /*break*/, 9];
            case 8:
                try {
                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                }
                finally { if (e_1) throw e_1.error; }
                return [7 /*endfinally*/];
            case 9: return [2 /*return*/];
        }
    });
}
function reconnect() {
    var action, _a, _b, connection, e_2_1;
    var e_2, _c;
    return tslib_1.__generator(this, function (_d) {
        switch (_d.label) {
            case 0: return [4 /*yield*/, effects_1.take("@@element/reconnectable/RECONNECT" /* RECONNECT */)];
            case 1:
                action = _d.sent();
                _d.label = 2;
            case 2:
                _d.trys.push([2, 7, 8, 9]);
                _a = tslib_1.__values(action.payload.connections), _b = _a.next();
                _d.label = 3;
            case 3:
                if (!!_b.done) return [3 /*break*/, 6];
                connection = _b.value;
                return [4 /*yield*/, effects_1.call(recalc, connection.id)];
            case 4:
                _d.sent();
                _d.label = 5;
            case 5:
                _b = _a.next();
                return [3 /*break*/, 3];
            case 6: return [3 /*break*/, 9];
            case 7:
                e_2_1 = _d.sent();
                e_2 = { error: e_2_1 };
                return [3 /*break*/, 9];
            case 8:
                try {
                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                }
                finally { if (e_2) throw e_2.error; }
                return [7 /*endfinally*/];
            case 9: return [2 /*return*/];
        }
    });
}
function update() {
    var action, elements, _a, _b, value, e_3_1;
    var e_3, _c;
    return tslib_1.__generator(this, function (_d) {
        switch (_d.label) {
            case 0: return [4 /*yield*/, effects_1.take("@@element/UPDATE" /* UPDATE */)];
            case 1:
                action = _d.sent();
                return [4 /*yield*/, effects_1.select()];
            case 2:
                elements = (_d.sent()).elements;
                _d.label = 3;
            case 3:
                _d.trys.push([3, 8, 9, 10]);
                _a = tslib_1.__values(action.payload.values), _b = _a.next();
                _d.label = 4;
            case 4:
                if (!!_b.done) return [3 /*break*/, 7];
                value = _b.value;
                if (!uml_relationship_1.UMLRelationship.isUMLRelationship(elements[value.id])) {
                    return [3 /*break*/, 6];
                }
                return [4 /*yield*/, effects_1.call(recalc, value.id)];
            case 5:
                _d.sent();
                _d.label = 6;
            case 6:
                _b = _a.next();
                return [3 /*break*/, 4];
            case 7: return [3 /*break*/, 10];
            case 8:
                e_3_1 = _d.sent();
                e_3 = { error: e_3_1 };
                return [3 /*break*/, 10];
            case 9:
                try {
                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                }
                finally { if (e_3) throw e_3.error; }
                return [7 /*endfinally*/];
            case 10: return [2 /*return*/];
        }
    });
}
function layoutElement() {
    var action, elements, relationships, updates, relationships_1, relationships_1_1, relationship, source, target, _a, _b, id, e_4_1;
    var e_5, _c, e_4, _d;
    return tslib_1.__generator(this, function (_e) {
        switch (_e.label) {
            case 0: return [4 /*yield*/, effects_1.take(["@@element/movable/MOVE" /* MOVE */, "@@element/resizable/RESIZE" /* RESIZE */])];
            case 1:
                action = _e.sent();
                return [4 /*yield*/, effects_1.select()];
            case 2:
                elements = (_e.sent()).elements;
                relationships = Object.values(elements).filter(function (x) { return uml_relationship_1.UMLRelationship.isUMLRelationship(x); });
                updates = [];
                try {
                    loop: for (relationships_1 = tslib_1.__values(relationships), relationships_1_1 = relationships_1.next(); !relationships_1_1.done; relationships_1_1 = relationships_1.next()) {
                        relationship = relationships_1_1.value;
                        source = relationship.source.element;
                        while (source) {
                            if (action.payload.ids.includes(source)) {
                                updates.push(relationship.id);
                                continue loop;
                            }
                            source = elements[source].owner;
                        }
                        target = relationship.target.element;
                        while (target) {
                            if (action.payload.ids.includes(target)) {
                                updates.push(relationship.id);
                                continue loop;
                            }
                            target = elements[target].owner;
                        }
                    }
                }
                catch (e_5_1) { e_5 = { error: e_5_1 }; }
                finally {
                    try {
                        if (relationships_1_1 && !relationships_1_1.done && (_c = relationships_1.return)) _c.call(relationships_1);
                    }
                    finally { if (e_5) throw e_5.error; }
                }
                _e.label = 3;
            case 3:
                _e.trys.push([3, 8, 9, 10]);
                _a = tslib_1.__values(tslib_1.__spread(new Set(tslib_1.__spread(updates)))), _b = _a.next();
                _e.label = 4;
            case 4:
                if (!!_b.done) return [3 /*break*/, 7];
                id = _b.value;
                return [4 /*yield*/, effects_1.call(recalc, id)];
            case 5:
                _e.sent();
                _e.label = 6;
            case 6:
                _b = _a.next();
                return [3 /*break*/, 4];
            case 7: return [3 /*break*/, 10];
            case 8:
                e_4_1 = _e.sent();
                e_4 = { error: e_4_1 };
                return [3 /*break*/, 10];
            case 9:
                try {
                    if (_b && !_b.done && (_d = _a.return)) _d.call(_a);
                }
                finally { if (e_4) throw e_4.error; }
                return [7 /*endfinally*/];
            case 10: return [2 /*return*/];
        }
    });
}
function deleteElement() {
    var action, elements, relationships;
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, effects_1.take("@@element/DELETE" /* DELETE */)];
            case 1:
                action = _a.sent();
                return [4 /*yield*/, effects_1.select()];
            case 2:
                elements = (_a.sent()).elements;
                relationships = Object.values(elements)
                    .filter(function (x) { return uml_relationship_1.UMLRelationship.isUMLRelationship(x); })
                    .filter(function (relationship) {
                    return action.payload.ids.includes(relationship.source.element) ||
                        action.payload.ids.includes(relationship.target.element);
                })
                    .map(function (relationship) { return relationship.id; });
                return [4 /*yield*/, effects_1.all([
                        effects_1.put({
                            type: "@@element/container/REMOVE" /* REMOVE */,
                            payload: { ids: relationships },
                            undoable: false,
                        }),
                        effects_1.put({
                            type: "@@element/DELETE" /* DELETE */,
                            payload: { ids: relationships },
                            undoable: false,
                        }),
                    ])];
            case 3:
                _a.sent();
                return [2 /*return*/];
        }
    });
}
function recalc(id) {
    var elements, layer, relationship, source, target, sourcePosition, targetPosition, original, _a, updates, _b, path, bounds;
    return tslib_1.__generator(this, function (_c) {
        switch (_c.label) {
            case 0: return [4 /*yield*/, effects_1.select()];
            case 1:
                elements = (_c.sent()).elements;
                return [4 /*yield*/, effects_1.getContext('layer')];
            case 2:
                layer = _c.sent();
                relationship = uml_relationship_repository_1.UMLRelationshipRepository.get(elements[id]);
                if (!relationship) {
                    return [2 /*return*/];
                }
                source = uml_element_repository_1.UMLElementRepository.get(elements[relationship.source.element]);
                target = uml_element_repository_1.UMLElementRepository.get(elements[relationship.target.element]);
                if (!source || !target) {
                    return [2 /*return*/];
                }
                return [4 /*yield*/, effects_1.put(uml_element_repository_1.UMLElementRepository.getAbsolutePosition(relationship.source.element))];
            case 3:
                sourcePosition = _c.sent();
                source.bounds = tslib_1.__assign(tslib_1.__assign({}, source.bounds), sourcePosition);
                return [4 /*yield*/, effects_1.put(uml_element_repository_1.UMLElementRepository.getAbsolutePosition(relationship.target.element))];
            case 4:
                targetPosition = _c.sent();
                target.bounds = tslib_1.__assign(tslib_1.__assign({}, target.bounds), targetPosition);
                original = elements[id];
                _a = tslib_1.__read(relationship.render(layer, source, target), 1), updates = _a[0];
                _b = diff_1.diff(original, updates), path = _b.path, bounds = _b.bounds;
                if (!path) return [3 /*break*/, 6];
                return [4 /*yield*/, effects_1.put(uml_relationship_repository_1.UMLRelationshipRepository.layout(updates.id, path, tslib_1.__assign(tslib_1.__assign({}, original.bounds), bounds)))];
            case 5:
                _c.sent();
                _c.label = 6;
            case 6: return [2 /*return*/];
        }
    });
}
exports.recalc = recalc;
//# sourceMappingURL=uml-relationship-saga.js.map