"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var react_1 = tslib_1.__importStar(require("react"));
var react_dom_1 = require("react-dom");
var defaultProps = Object.freeze({
    x: 0,
    y: 0,
    dx: 0,
    dy: 0,
    angle: 0,
    width: undefined,
    height: undefined,
    lineHeight: 16,
    capHeight: 11,
    scaleToFit: false,
    textAnchor: 'middle',
    verticalAnchor: 'middle',
});
var initialState = Object.freeze({
    wordsByLines: [],
});
var Multiline = /** @class */ (function (_super) {
    tslib_1.__extends(Multiline, _super);
    function Multiline() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = initialState;
        _this.spaceWidth = 0;
        _this.wordsWithComputedWidth = [];
        _this.calculateWordWidths = function (props) {
            try {
                var words = props.children ? props.children.toString().split(/\s+/) : [];
                var wordsWithComputedWidth = words.map(function (word) { return ({ word: word, width: _this.getStringWidth(word, props.style) }); });
                var spaceWidth = _this.getStringWidth('\u00A0', props.style);
                return { wordsWithComputedWidth: wordsWithComputedWidth, spaceWidth: spaceWidth };
            }
            catch (e) {
                return null;
            }
        };
        return _this;
    }
    Multiline.prototype.componentDidMount = function () {
        this.updateWordsByLines(this.props, true);
    };
    Multiline.prototype.componentWillReceiveProps = function (nextProps) {
        var needCalculate = this.props.children !== nextProps.children || this.props.style !== nextProps.style;
        this.updateWordsByLines(nextProps, needCalculate);
    };
    Multiline.prototype.getStringWidth = function (str, style) {
        try {
            // Calculate length of each word to be used to determine number of words per line
            var container = react_dom_1.findDOMNode(this);
            if (!container) {
                return 0;
            }
            var text = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
            container.appendChild(text);
            Object.assign(text.style, style);
            text.textContent = str;
            var width = text.getComputedTextLength();
            container.removeChild(text);
            return width;
        }
        catch (e) {
            return 0;
        }
    };
    Multiline.prototype.updateWordsByLines = function (props, needCalculate) {
        // Only perform calculations if using features that require them (multiline, scaleToFit)
        if (props.width || props.scaleToFit) {
            if (needCalculate) {
                var wordWidths = this.calculateWordWidths(props);
                if (wordWidths) {
                    var wordsWithComputedWidth = wordWidths.wordsWithComputedWidth, spaceWidth = wordWidths.spaceWidth;
                    this.wordsWithComputedWidth = wordsWithComputedWidth;
                    this.spaceWidth = spaceWidth;
                }
                else {
                    this.updateWordsWithoutCalculate(props);
                    return;
                }
            }
            var wordsByLines = this.calculateWordsByLines(this.wordsWithComputedWidth, this.spaceWidth, props.width);
            this.setState({ wordsByLines: wordsByLines });
        }
        else {
            this.updateWordsWithoutCalculate(props);
        }
    };
    Multiline.prototype.updateWordsWithoutCalculate = function (props) {
        var words = props.children ? props.children.toString().split(/\s+/) : [];
        this.setState({ wordsByLines: [{ words: words, width: 0 }] });
    };
    Multiline.prototype.calculateWordsByLines = function (wordsWithComputedWidth, spaceWidth, lineWidth) {
        var scaleToFit = this.props.scaleToFit;
        return wordsWithComputedWidth.reduce(function (result, _a) {
            var word = _a.word, width = _a.width;
            var currentLine = result[result.length - 1];
            if (currentLine && (!lineWidth || scaleToFit || currentLine.width + width + spaceWidth < lineWidth)) {
                // Word can be added to an existing line
                currentLine.words.push(word);
                currentLine.width += width + spaceWidth;
            }
            else {
                // Add first word to line or word is too long to scaleToFit on existing line
                var newLine = { words: [word], width: width };
                result.push(newLine);
            }
            return result;
        }, []);
    };
    Multiline.prototype.render = function () {
        var _a = this.props, dx = _a.dx, dy = _a.dy, textAnchor = _a.textAnchor, verticalAnchor = _a.verticalAnchor, scaleToFit = _a.scaleToFit, angle = _a.angle, lineHeight = _a.lineHeight, capHeight = _a.capHeight, textProps = tslib_1.__rest(_a, ["dx", "dy", "textAnchor", "verticalAnchor", "scaleToFit", "angle", "lineHeight", "capHeight"]);
        var wordsByLines = this.state.wordsByLines;
        var x = textProps.x + dx;
        var y = textProps.y + dy;
        var startDy;
        switch (verticalAnchor) {
            case 'start':
                startDy = capHeight;
                break;
            case 'middle':
                startDy = ((wordsByLines.length - 1) / 2) * -lineHeight + capHeight / 2;
                break;
            default:
                startDy = wordsByLines.length - 1 * -lineHeight;
                break;
        }
        var transforms = [];
        if (scaleToFit && wordsByLines.length) {
            var lineWidth = wordsByLines[0].width;
            var sx = (this.props.width || 0) / lineWidth;
            var sy = sx;
            var originX = x - sx * x;
            var originY = y - sy * y;
            transforms.push("matrix(" + sx + ", 0, 0, " + sy + ", " + originX + ", " + originY + ")");
        }
        if (angle) {
            transforms.push("rotate(" + angle + ", " + x + ", " + y + ")");
        }
        if (transforms.length) {
            textProps.transform = transforms.join(' ');
        }
        return (react_1.default.createElement("text", tslib_1.__assign({ x: x, y: y, textAnchor: textAnchor }, textProps, { pointerEvents: "none" }), wordsByLines.map(function (line, index) { return (react_1.default.createElement("tspan", { x: x, dy: index === 0 ? startDy : lineHeight, key: index }, line.words.join(' '))); })));
    };
    Multiline.defaultProps = defaultProps;
    return Multiline;
}(react_1.Component));
exports.Multiline = Multiline;
//# sourceMappingURL=multiline.js.map