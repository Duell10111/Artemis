"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var react_1 = require("react");
var react_dom_1 = require("react-dom");
var components_1 = require("../../packages/components");
function computeBoundingBox(points) {
    var e_1, _a;
    if (points.length === 0) {
        return { x: 0, y: 0, width: 0, height: 0 };
    }
    var firstPoint = points[0];
    var minX = firstPoint.x;
    var minY = firstPoint.y;
    var maxX = firstPoint.x;
    var maxY = firstPoint.y;
    try {
        for (var points_1 = tslib_1.__values(points), points_1_1 = points_1.next(); !points_1_1.done; points_1_1 = points_1.next()) {
            var p = points_1_1.value;
            if (p.x < minX)
                minX = p.x;
            if (p.y < minY)
                minY = p.y;
            if (p.x > maxX)
                maxX = p.x;
            if (p.y > maxY)
                maxY = p.y;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (points_1_1 && !points_1_1.done && (_a = points_1.return)) _a.call(points_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY,
    };
}
exports.computeBoundingBox = computeBoundingBox;
function computeBoundingBoxForElements(elements) {
    if (!elements.length) {
        return { x: 0, y: 0, width: 0, height: 0 };
    }
    var boundaries = elements.map(function (element) { return (tslib_1.__assign({}, element.bounds)); });
    var x = Math.min.apply(Math, tslib_1.__spread(boundaries.map(function (bounds) { return bounds.x; })));
    var y = Math.min.apply(Math, tslib_1.__spread(boundaries.map(function (bounds) { return bounds.y; })));
    var width = Math.max.apply(Math, tslib_1.__spread(boundaries.map(function (bounds) { return bounds.x + bounds.width; }))) - x;
    var height = Math.max.apply(Math, tslib_1.__spread(boundaries.map(function (bounds) { return bounds.y + bounds.height; }))) - y;
    return { x: x, y: y, width: width, height: height };
}
exports.computeBoundingBoxForElements = computeBoundingBoxForElements;
function computeBoundingBoxForRelationship(container, relationship) {
    var Component = components_1.Components[relationship.type];
    var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('x', "" + relationship.bounds.x);
    svg.setAttribute('y', "" + relationship.bounds.y);
    svg.style.visibility = 'none';
    container.appendChild(svg);
    var element = react_1.createElement(Component, { element: relationship });
    react_dom_1.render(element, svg);
    var parent = container.getBoundingClientRect();
    var child = svg.getBoundingClientRect();
    var bounds = { x: child.left - parent.left, y: child.top - parent.top, width: child.width, height: child.height };
    react_dom_1.unmountComponentAtNode(svg);
    container.removeChild(svg);
    return bounds;
}
exports.computeBoundingBoxForRelationship = computeBoundingBoxForRelationship;
//# sourceMappingURL=boundary.js.map