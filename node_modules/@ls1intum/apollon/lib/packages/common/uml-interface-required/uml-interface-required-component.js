"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var react_1 = tslib_1.__importDefault(require("react"));
var react_redux_1 = require("react-redux");
var uml_interface_required_1 = require("./uml-interface-required");
var uml_element_port_1 = require("../../../services/uml-element/uml-element-port");
var point_1 = require("../../../utils/geometry/point");
var SIZE = 26;
var enhance = react_redux_1.connect(function (state, props) {
    // filter all UMLInterfaceRequired
    var requiredInterfaces = state.diagram.ownedRelationships
        .map(function (relationshipId) { return state.elements[relationshipId]; })
        .filter(function (relationship) { return uml_interface_required_1.UMLInterfaceRequired.isUMLInterfaceRequired(relationship); })
        .map(function (relationship) { return relationship; });
    // check if any other UMLInterfaceRequired has the same target as this element and if the direction of the UMLInterfaceRequired is the opposite
    return {
        hasOppositeRequiredInterface: requiredInterfaces
            .filter(function (element) { return element.id !== props.element.id; })
            .some(function (otherRequiredInterface) {
            return otherRequiredInterface.target.element === props.element.target.element &&
                otherRequiredInterface.target.direction.valueOf() ===
                    uml_element_port_1.getOppositeDirection(props.element.target.direction).valueOf();
        }),
    };
}, {});
var UMLInterfaceRequiredC = function (props) {
    var element = props.element, hasOppositeRequiredInterface = props.hasOppositeRequiredInterface;
    // offset for last point in paragraph, so that line ends at marker
    var offset;
    switch (element.target.direction) {
        case uml_element_port_1.Direction.Up:
            offset = new point_1.Point(0, -3);
            break;
        case uml_element_port_1.Direction.Down:
            offset = new point_1.Point(0, 3);
            break;
        case uml_element_port_1.Direction.Right:
            offset = new point_1.Point(3, 0);
            break;
        case uml_element_port_1.Direction.Left:
            offset = new point_1.Point(-3, 0);
            break;
    }
    return (react_1.default.createElement("g", null,
        react_1.default.createElement("marker", { id: "marker-" + element.id, viewBox: "0 0 " + SIZE + " " + SIZE, markerWidth: SIZE, markerHeight: SIZE, refX: "0", refY: "0", orient: "auto", markerUnits: "strokeWidth", strokeDasharray: "1,0" },
            react_1.default.createElement("path", { d: "M " + (SIZE / 2 - (hasOppositeRequiredInterface ? 5 : 0)) + " -" + (SIZE - (hasOppositeRequiredInterface ? 2 : 0)) / 2 + " a " + SIZE / 2 + "," + SIZE / 2 + " 0 0 0 0," + (SIZE - (hasOppositeRequiredInterface ? 2 : 0)), fill: "none", stroke: "black", strokeWidth: 2 })),
        react_1.default.createElement("polyline", { points: element.path
                .map(function (point, index) {
                if (index === element.path.length - 1) {
                    point = new point_1.Point(point.x, point.y).add(offset);
                }
                return point.x + " " + point.y;
            })
                .join(','), stroke: "black", fill: "none", strokeWidth: 1, markerEnd: "url(#marker-" + element.id + ")" })));
};
exports.UMLInterfaceRequiredComponent = enhance(UMLInterfaceRequiredC);
//# sourceMappingURL=uml-interface-required-component.js.map